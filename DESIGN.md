# Design & Decisions

## 1. Architectural Overview

This project implements a privacy-preserving Rock-Paper-Scissors game where game logic is executed on encrypted data. The architecture prioritizes gas efficiency and scalability using a Factory/Clone pattern.

### Key Components
* **`RPS.sol` (Logic):** Handles FHE operations, state management, and move verification.
* **`RPSClub.sol` (Factory):** Deploys lightweight EIP-1167 Minimal Proxies to allow users to spawn cheap game instances.
* **Bitmask State:** Game state is packed into a single encrypted `uint8` to minimize storage and decryption costs.
* **Self-Relay (v0.9):** Adheres to the latest FHEVM architecture where the client orchestrates the decryption and resolution flow.

---

## 2. Key Technical Decisions

### A. The `uint8` Bitmask Optimization
Instead of storing two separate encrypted variables (e.g., `euint8 p1Move`, `euint8 p2Move`), the entire game state is packed into one storage slot.
* **Layout:** `[unused:2] [P2_Move:3] [P1_Move:3]`
* **Trade-off:** Increases complexity of bitwise logic during resolution.
* **Benefit:** Reduces FHE storage writes (the most expensive operation in fhEVM) by 50%. We perform a single `FHE.or` update rather than multiple writes. It also reduces the decryption payload to a single handle.

### B. Solving the Proxy Initialization Problem
Standard Zama contracts initialize the FHE Coprocessor configuration in the `constructor`. This breaks EIP-1167 Clones because constructors do not run for proxies, leaving the Input Verifier address as `0x0`.
* **Solution:** `ZamaEthereumConfigInitializable`, a custom abstract contract that moves configuration logic into an explicit `__ZamaEthereumConfig_init()` function called by the proxy's `initialize()`.
* **Design Choice:** A custom `initializer` modifier to avoid a hard dependency on OpenZeppelin's `Initializable.sol`, keeping the contract lightweight.

### C. System Design: Integrity & Idempotency
* **Request Integrity:** Guaranteed via ZK Input Proofs. Every `play()` transaction must include a valid proof generated by the SDK, ensuring the ciphertext encrypts a valid 8-bit integer.
* **Result Integrity:** Guaranteed via KMS Signatures. The `resolveGame` function uses `FHE.verifySignatures()` to ensure the submitted cleartext matches the on-chain encrypted handle.
* **Idempotency:** To prevent replay attacks or double submissions, EVM boolean flags (`player1Moved`) as a "guard clause." Checking plaintext booleans is significantly cheaper than running FHE logic, allowing the transaction to fail fast before engaging the coprocessor.

### D. Single-Player Mode & On-Chain Randomness

The contract supports a single-player mode where the opponent is the contract itself. This is achieved using FHEVM's built-in capabilities for confidential on-chain randomness.

*   **Mechanism:** When a player submits a move and the opponent is `address(0)`, the contract calls `FHE.randEuint8()`. This function generates an encrypted random `uint8` inside the FHE coprocessor.
*   **Confidentiality:** The random number is never revealed to the player, the validator, or the contract itself. All subsequent logic (mapping the random number to a ROCK, PAPER, or SCISSORS move) is performed on the encrypted value.
*   **Verifiability:** This approach avoids the need for external oracles (like Chainlink VRF), keeping the system self-contained and reducing attack vectors. The randomness is verifiably generated as part of the FHE execution.

### F. Local vs. Testnet Strategy
* **Unit Tests (Local):** Used `fhevm.mock` mode for fast feedback on contract logic (math, bitmasking, win conditions) without waiting for blocks.
* **Integration (Sepolia):** Used the public Testnet for the CLI Tasks.
* **Decision:** I chose NOT to run the full end-to-end `resolve` flow locally.
    * *Reason:* The `@zama-fhe/relayer-sdk` requires a running Relayer/Gateway service. Setting up the full Zama Docker infrastructure (Gateway + KMS + Node) introduces significant configuration overhead compared to the value added.
    * *Result:* The CLI tasks are configured to target Sepolia where the infrastructure is managed.

---

## 3. Debugging Report

During development on the Sepolia testnet, the `rps:resolve` task failed with `HTTP 500` and `HTTP 520` errors from the Zama Relayer.

**Triage Process:**
1.  **Isolation:** Verified that the `play` transaction succeeded on Etherscan. This ruled out contract logic failure. The error came strictly from the SDK/Relayer communication.
2.  **Hypothesis A (Indexing Lag):** `HTTP 520/504` might indicate the Relayer hasn't indexed the `makePubliclyDecryptable` event yet.
    * *Fix:* Added a `retry()` wrapper with exponential backoff to the Hardhat task.
3.  **Hypothesis B (Malformed Input):** `HTTP 500` usually implies a parser crash.
    * *Investigation:* Logged the handle being sent to the SDK. Ethers.js `toBeHex` was trimming leading zeros (e.g., `0x4ea...`), but the Relayer expects a strict 32-byte hex string.
    * *Fix:* Applied `ethers.zeroPadValue(handle, 32)` to ensure strict 64-character hex formatting.
4.  **Validation:** After padding the handle, the 500 error resolved. The retry logic handled the remaining transient 520/504 timeouts.

---

## 4. Reflection

### If I had more time
1.  **Private Result Reveal (EIP-712):** Currently, `resolveGame` makes the result public. Instead the deployer contract could specify a callback hook that executes on encrypted logic. That could be implemented as encrypted callback, leaving it for downstream to decide upon the whether to make the results globally accessable or use it e.g. for confidential token minting instead. 
2.  **Strict ZK Range Proofs:** The bitmask logic allows invalid inputs (e.g., 3 or 7). While the contract defaults these to a loss, enforcing `input \in {1, 2, 4}` at the ZK proof generation level would improve DX.
3.  **Frontend UI:** A React interface using the `fhevm-react-template` would demonstrate the user flow (signing the re-encryption request) better than the CLI.

### AI Coding Assistance
* **What worked:** AI was excellent for scaffolding the boilerplate (Hardhat Tasks, Ethers.js interactions) and generating the initial Factory structure.
* **What failed:** AI models frequently hallucinated outdated FHEVM syntax (v0.5). They consistently suggested the deprecated `FHE.req` or the old Oracle callback pattern.
* **Resolution:** I had to manually cross-reference the [Zama v0.9 Migration Guide](https://docs.zama.ai/protocol/solidity-guides/development-guide/migration) to rewrite the decryption flow using the `@zama-fhe/relayer-sdk` and `FHE.verifySignatures`.
